<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>webpack-初探</title>
      <link href="/2020/01/06/webpack-%E5%88%9D%E6%8E%A2/"/>
      <url>/2020/01/06/webpack-%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<blockquote><p><code>webpack</code> 将程序员编写的源代码，经过压缩、编译、语法检查等一系列操作，编译成浏览器可以识别的代码，优化性能。</p></blockquote><h1 id="Webpack基本介绍"><a href="#Webpack基本介绍" class="headerlink" title="Webpack基本介绍"></a>Webpack基本介绍</h1><h2 id="概念的引入"><a href="#概念的引入" class="headerlink" title="概念的引入"></a>概念的引入</h2><p>在网页中，我们经常会引入<code>JS</code> <code>CSS</code> <code>Img</code> <code>Fonts</code> <code>vue</code> 等这类的静态资源，这个时候我们来了两个问题：</p><ol><li><code>vue</code> <code>ejs</code> 等文件以及 <code>es6</code>的新语法、模块化开发浏览器读不懂啊！</li><li>网页加载速度慢，要多次重复的发生资源请求！</li></ol><p>如何解决这两个问题呢？别急，这个时候<code>webpack</code>的作用就来了！</p><h2 id="什么是Webpack"><a href="#什么是Webpack" class="headerlink" title="什么是Webpack"></a>什么是Webpack</h2><p>Webpack是一个前端的模块打包器，基于node开发出来的一个前端工具，将前端所有静态资源都当作模块处理。</p><h2 id="Webpack支持的规范"><a href="#Webpack支持的规范" class="headerlink" title="Webpack支持的规范"></a>Webpack支持的规范</h2><ol><li>ES6规范</li><li>CommonJS规范</li><li>AMD规范</li><li>CMD规范</li></ol><h1 id="Webpack基本使用"><a href="#Webpack基本使用" class="headerlink" title="Webpack基本使用"></a>Webpack基本使用</h1><h2 id="创建基本目录结构"><a href="#创建基本目录结构" class="headerlink" title="创建基本目录结构"></a>创建基本目录结构</h2><p>在 <code>CMD</code> 中运行：</p><pre><code class="bash">mkdir webpackcd webpacknpm init</code></pre><p>可以直接通过<code>CMD</code> 创建简单的文件，也可以直接创建：</p><pre><code class="powershell">type nul&gt;index.htmltype nul&gt;index.jstype nul&gt;webpack.config.js</code></pre><p><strong>index.html:</strong></p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;    &lt;title&gt;webpack-初探&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;script src=&quot;./dist/main.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>这里<strong>html</strong>里引入的 main.js 现在是没有的，一会将会把index.js 打包成 dist下的 mian.js</p><p><strong>index.js:</strong></p><pre><code class="js">console.log(&#39;webapck-初探&#39;);</code></pre><h2 id="安装Webpack"><a href="#安装Webpack" class="headerlink" title="安装Webpack"></a>安装Webpack</h2><p>在开始之前，请确保安装了<code>Node.js</code>的最新版本，使用旧版本，你可能遇到各种问题，因为它们可能缺少 webpack 功能以及/或者缺少相关 package 包。</p><p>要安装最新版本或特定版本，请运行以下命运之一：</p><pre><code class="bash">npm install --save-dev webpacknpm install --save-dev webpack@&lt;version&gt;</code></pre><p>如果你使用webpack 4+ 版本，你还需要安装 CLI。</p><pre><code class="bash">npm install --save-dev webpack-cli</code></pre><p>你也可以全局安装，这样就能在全局使用<code>webpack</code>命令，但是官方不推荐全局安装webpack。这会将你项目中的 webpack 锁定到指定版本，并且在使用不同的webpack版本项目中，可能会导致<strong>构建失败</strong>。</p><pre><code class="bash">npm install --global webpacknpm install --global webpack-cli</code></pre><h2 id="Webpack基本配置"><a href="#Webpack基本配置" class="headerlink" title="Webpack基本配置"></a>Webpack基本配置</h2><p>在<code>webpack.config.js</code>里写入：</p><pre><code class="javascript">const path = require(&#39;path&#39;);module.exports = {    entry: &#39;./index.js&#39;,   //  入口文件    output: {   //  出口文件配置        path: path.resolve(__dirname, &#39;dist&#39;),        filename: &#39;main.js&#39;,    },    mode: &#39;development&#39;,  //  模式：开发 development   生产 production}</code></pre><p>配置好后命令行敲入：</p><pre><code class="bash">webpack</code></pre><p>该命令会自动寻找根目录下的<code>webpack.config.js</code>，根据配置进行打包，这个时候我们就可以看到根目录多了<code>dist</code>目录，里面有一个<strong>main.js</strong>。</p><h1 id="Webpack四大核心"><a href="#Webpack四大核心" class="headerlink" title="Webpack四大核心"></a>Webpack四大核心</h1><h2 id="入口-entry"><a href="#入口-entry" class="headerlink" title="入口(entry)"></a>入口(entry)</h2><p><strong>入口起点</strong>指示 webpack 应该使用哪个模块，来作为构建内部<em>依赖图</em>的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和简介）依赖的。</p><p> 每个依赖项随即被处理，最后输出到称之为 <em>bundles</em> 的文件中，我们将在下一章节详细讨论这个过程。 </p><p>可以通过在 <a href="https://www.webpackjs.com/configuration" target="_blank" rel="noopener">webpack 配置</a>中配置 <code>entry</code> 属性，来指定一个入口起点（或多个入口起点）。默认值为 <code>./src</code>。 </p><p>接下来我们看一个简单的例子：</p><pre><code class="javascript">module.exports = {  entry: &#39;./path/to/my/entry/file.js&#39;};</code></pre><h2 id="出口-output"><a href="#出口-output" class="headerlink" title="出口(output)"></a>出口(output)</h2><p><strong>output</strong> 属性告诉 webpack 在哪里输出它所创建的 <em>bundles</em>，以及如何命名这些文件，默认值为 <code>./dist</code>。基本上，整个应用程序结构，都会被编译到你指定的输出路径的文件夹中。你可以通过在配置中指定一个 <code>output</code> 字段，来配置这些处理过程：</p><pre><code class="javascript">const path = require(&#39;path&#39;);module.exports = {  entry: &#39;./path/to/my/entry/file.js&#39;,  output: {    path: path.resolve(__dirname, &#39;dist&#39;),    filename: &#39;my-first-webpack.bundle.js&#39;  }};</code></pre><p>在上面的示例中，我们通过 <code>output.filename</code> 和 <code>output.path</code> 属性，来告诉 webpack bundle 的名称，以及我们想要 bundle 生成(emit)到哪里。可能你想要了解在代码最上面导入的 path 模块是什么，它是一个 <a href="https://nodejs.org/api/modules.html" target="_blank" rel="noopener">Node.js 核心模块</a>，用于操作文件路径。</p><h2 id="·loader"><a href="#·loader" class="headerlink" title="·loader"></a>·loader</h2><p><em>loader</em> 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效<a href="https://www.webpackjs.com/concepts/modules" target="_blank" rel="noopener">模块</a>，然后你就可以利用 webpack 的打包能力，对它们进行处理。</p><p>本质上，webpack loader 将所有类型的文件，转换为应用程序的依赖图（和最终的 bundle）可以直接引用的模块。</p><blockquote><p>注意，loader 能够 <code>import</code> 导入任何类型的模块（例如 <code>.css</code> 文件），这是 webpack 特有的功能，其他打包程序或任务执行器的可能并不支持。我们认为这种语言扩展是有很必要的，因为这可以使开发人员创建出更准确的依赖关系图。</p></blockquote><p>在更高层面，在 webpack 的配置中 <strong>loader</strong> 有两个目标：</p><ol><li><code>test</code> 属性，用于标识出应该被对应的 loader 进行转换的某个或某些文件。</li><li><code>use</code> 属性，表示进行转换时，应该使用哪个 loader。</li></ol><pre><code class="javascript">const path = require(&#39;path&#39;);const config = {  output: {    filename: &#39;my-first-webpack.bundle.js&#39;  },  module: {    rules: [      { test: /\.txt$/, use: &#39;raw-loader&#39; }    ]  }};module.exports = config;</code></pre><p>以上配置中，对一个单独的 module 对象定义了 <code>rules</code> 属性，里面包含两个必须属性：<code>test</code> 和 <code>use</code>。这告诉 webpack 编译器(compiler) 如下信息：</p><blockquote><p>“嘿，webpack 编译器，当你碰到「在 <code>require()</code>/<code>import</code> 语句中被解析为 ‘.txt’ 的路径」时，在你对它打包之前，先<strong>使用</strong> <code>raw-loader</code> 转换一下。”</p></blockquote><h2 id="插件-plugins"><a href="#插件-plugins" class="headerlink" title="插件(plugins)"></a>插件(plugins)</h2><p>loader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。<a href="https://www.webpackjs.com/api/plugins" target="_blank" rel="noopener">插件接口</a>功能极其强大，可以用来处理各种各样的任务。</p><p>想要使用一个插件，你只需要 <code>require()</code> 它，然后把它添加到 <code>plugins</code> 数组中。多数插件可以通过选项(option)自定义。你也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 <code>new</code> 操作符来创建它的一个实例。</p><p><strong>webpack.config.js</strong></p><pre><code class="javascript">const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;); // 通过 npm 安装const webpack = require(&#39;webpack&#39;); // 用于访问内置插件const config = {  module: {    rules: [      { test: /\.txt$/, use: &#39;raw-loader&#39; }    ]  },  plugins: [    new HtmlWebpackPlugin({template: &#39;./src/index.html&#39;})  ]};module.exports = config;</code></pre><h1 id="webpack-dev-server的使用"><a href="#webpack-dev-server的使用" class="headerlink" title="webpack-dev-server的使用"></a>webpack-dev-server的使用</h1><p>每次改完代码，都需要手动执行<code>webpack</code>命令打包编译文件，比较繁琐；这个时候我们可以使用热加载：</p><h2 id="安装webpack-dev-server："><a href="#安装webpack-dev-server：" class="headerlink" title="安装webpack-dev-server："></a>安装<code>webpack-dev-server</code>：</h2><pre><code class="javascript">npm install webpack-dev-server -D</code></pre><h2 id="在webpack-config-js中配置："><a href="#在webpack-config-js中配置：" class="headerlink" title="在webpack.config.js中配置："></a>在<code>webpack.config.js</code>中配置：</h2><pre><code class="js">const path = require(&#39;path&#39;);const webpack = require(&#39;webpack&#39;);module.exports = {    entry: &#39;./js/a.js&#39;,    output: {        path: path.resolve(__dirname, &#39;dist&#39;),        filename: &#39;main.js&#39;,    },    mode: &#39;development&#39;,    devServer: {      contentBase: &#39;./&#39;,      compress: true,      port: 9000,         hot: true    },    plugins: [        new webpack.NamedModulesPlugin(),        new webpack.HotModuleReplacementPlugin()    ],}</code></pre><h2 id="在package-json里面的scripts属性里面添加webpack-dev-server命令到开发环境"><a href="#在package-json里面的scripts属性里面添加webpack-dev-server命令到开发环境" class="headerlink" title="在package.json里面的scripts属性里面添加webpack-dev-server命令到开发环境"></a>在<code>package.json</code>里面的<code>scripts</code>属性里面添加<code>webpack-dev-server</code>命令到开发环境</h2><pre><code class="js">&quot;scripts&quot;: {    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,    &quot;dev&quot;: &quot;webpack-dev-server&quot;  },</code></pre><h2 id="执行npm-run-dev"><a href="#执行npm-run-dev" class="headerlink" title="执行npm run dev:"></a>执行<code>npm run dev</code>:</h2><pre><code class="bash">npm run dev</code></pre><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p><code>Webpack</code>是大家必须要学习的一项工具，本篇文章就暂且结束了，后面我会更新如何打包css、img，按需加载以及一些插件使用了；</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.webpackjs.com/concepts/" target="_blank" rel="noopener">Webpack官网</a></li><li><a href="https://juejin.im/post/5d2fd19be51d4576bc1a0eb0#heading-13" target="_blank" rel="noopener">Webpack基本使用</a></li><li><a href="https://juejin.im/post/5b59d83de51d45195f0b4790" target="_blank" rel="noopener">Webpack入门教程</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> webpack </tag>
            
            <tag> 前端打包工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对ES6-proxy的理解</title>
      <link href="/2020/01/05/%E5%AF%B9ES6-proxy%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2020/01/05/%E5%AF%B9ES6-proxy%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="对ES6-proxy的理解"><a href="#对ES6-proxy的理解" class="headerlink" title="对ES6-proxy的理解"></a>对ES6-proxy的理解</h1><blockquote><p>ES6(ECMAScript2015) 是 <code>JavaScript</code> 一个版本标准，作为前端爱好者是必须要掌握的，本篇记录我对ES6中，<code>proxy</code> 的理解。</p></blockquote><h2 id="字面理解"><a href="#字面理解" class="headerlink" title="字面理解"></a>字面理解</h2><p><code>Proxy</code> 在英语中是代理的意思，那我们就引发了几个疑问：</p><ol><li>它代理了什么？</li><li>为什么要代理？</li><li>如何使用代理？</li></ol><p>首先我们引用阮老师的 <code>《ECMAScript 6 入门》</code> 书籍中的概述：</p><blockquote><p>Proxy 可以理解成，在<strong>目标对象</strong>之前架设一层“拦截器”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p></blockquote><p>那么通过阮老师的这句话，我们可以得出第一个问题的答案：</p><p><strong>它代理了对象</strong></p><h2 id="为什么要代理"><a href="#为什么要代理" class="headerlink" title="为什么要代理"></a>为什么要代理</h2><p>第二个问题是为什么要使用 <code>proxy</code>？我总结了以下几点：</p><ul><li>拦截和监视外部对象的访问</li><li>降低函数或类的复杂度</li><li>在复杂操作前对操作进行校验或对所需资源进行管理</li></ul><p>先来一个不使用 <code>proxy</code> 的栗子：</p><pre><code class="js">let user = {    name: &#39;John&#39;,    surname: &#39;Doe&#39;};let printUser = (property) =&gt; {    let value = user[property];    if (!value) {        throw new Error(`The property [${property}] does not exist`);    } else {        console.log(`The user ${property} is ${value}`);    }}printUser(&#39;name&#39;); // 输出: &#39;The user name is John&#39;printUser(&#39;email&#39;); // 抛出错误: The property [email] does not exist</code></pre><p>这是一个简单的例子，我们有一个带有几个属性的用户对象，如果属性存在，我们想要打印用户信息，如果不存在，则抛出异常。通过上面的代码，你会发现：将条件和异常移到其他地方，而 <code>printUser</code> 中仅关注显示用户信息的实际逻辑会更好。这是我们可以使用代理对象的地方，让我们更新下这个例子。</p><pre><code class="javascript">let user = {    name: &#39;John&#39;,    surname: &#39;Doe&#39;};let proxy = new Proxy(user, {    get(target, property) {        let value = target[property];        if (!value) {            throw new Error(`The property [${property}] does not exist`);        }        return value;    }});let printUser = (property) =&gt; {    console.log(`The user ${property} is ${proxy[property]}`);};printUser(&#39;name&#39;); // 输出： &#39;The user name is John&#39;printUser(&#39;email&#39;); // 抛出错误: The property [email] does not exist</code></pre><p>在上面的示例中，我们包装了 <code>user</code> 对象，并设置了一个 <code>get</code> 方法。此方法充当拦截器，在返回值之前，会首先对属性值进行检查，如果不存在，则抛出异常。</p><p>输出与第一种情况相同，但此时 <code>printUser</code> 函数专注于逻辑，只处理消息。</p><h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><p>proxy除了代理get，set操作，还能代理其他的操作，如下：</p><pre><code class="js">handler.getPrototypeOf()// 在读取代理对象的原型时触发该操作，比如在执行 Object.getPrototypeOf(proxy) 时。handler.setPrototypeOf()// 在设置代理对象的原型时触发该操作，比如在执行 Object.setPrototypeOf(proxy, null) 时。handler.isExtensible()// 在判断一个代理对象是否是可扩展时触发该操作，比如在执行 Object.isExtensible(proxy) 时。handler.preventExtensions()// 在让一个代理对象不可扩展时触发该操作，比如在执行 Object.preventExtensions(proxy) 时。handler.getOwnPropertyDescriptor()// 在获取代理对象某个属性的属性描述时触发该操作，比如在执行 Object.getOwnPropertyDescriptor(proxy, &quot;foo&quot;) 时。handler.defineProperty()// 在定义代理对象某个属性时的属性描述时触发该操作，比如在执行 Object.defineProperty(proxy, &quot;foo&quot;, {}) 时。handler.has()// 在判断代理对象是否拥有某个属性时触发该操作，比如在执行 &quot;foo&quot; in proxy 时。handler.get()// 在读取代理对象的某个属性时触发该操作，比如在执行 proxy.foo 时。handler.set()// 在给代理对象的某个属性赋值时触发该操作，比如在执行 proxy.foo = 1 时。handler.deleteProperty()// 在删除代理对象的某个属性时触发该操作，比如在执行 delete proxy.foo 时。handler.ownKeys()// 在获取代理对象的所有属性键时触发该操作，比如在执行 Object.getOwnPropertyNames(proxy) 时。handler.apply()// 在调用一个目标对象为函数的代理对象时触发该操作，比如在执行 proxy() 时。handler.construct()// 在给一个目标对象为构造函数的代理对象构造实例时触发该操作，比如在执行new proxy() 时。</code></pre><h2 id="proxy栗子"><a href="#proxy栗子" class="headerlink" title="proxy栗子"></a>proxy栗子</h2><p>通过属性查找数组中的特定对象</p><p>以下代理为数组扩展了一些实用工具，可一看到，你可以灵活地“定义”属性，而不需要使用 <code>Object.defineProperties</code> 方法。</p><pre><code class="javascript">let products = new Proxy([  { name: &#39;Firefox&#39;, type: &#39;browser&#39; },  { name: &#39;SeaMonkey&#39;, type: &#39;browser&#39; },  { name: &#39;Thunderbird&#39;, type: &#39;mailer&#39; }],{  get: function(obj, prop) {    // 缺省行为是返回属性值， prop ?通常是一个整数    if (prop in obj) {      return obj[prop];    }    // 获取 products 的 number; 它是 products.length 的别名    if (prop === &#39;number&#39;) {      return obj.length;    }    let result, types = {};    for (let product of obj) {      if (product.name === prop) {        result = product;      }      if (types[product.type]) {        types[product.type].push(product);      } else {        types[product.type] = [product];      }    }    // 通过 name 获取 product    if (result) {      return result;    }    // 通过 type 获取 products    if (prop in types) {      return types[prop];    }    // 获取 product type    if (prop === &#39;types&#39;) {      return Object.keys(types);    }    return undefined;  }});console.log(products[0]); // { name: &#39;Firefox&#39;, type: &#39;browser&#39; }console.log(products[&#39;Firefox&#39;]); // { name: &#39;Firefox&#39;, type: &#39;browser&#39; }console.log(products[&#39;Chrome&#39;]); // undefinedconsole.log(products.browser); // [{ name: &#39;Firefox&#39;, type: &#39;browser&#39; }, { name: &#39;SeaMonkey&#39;, type: &#39;browser&#39; }]console.log(products.types); // [&#39;browser&#39;, &#39;mailer&#39;]console.log(products.number); // 3</code></pre><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li>MDN官网对 <code>proxy</code> 的解释： <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener" title="mdn官网对proxy解释">链接地址</a></li><li>阮老师 《ECMAScript 6 入门》 对 <code>proxy</code> 的解释： <a href="http://es6.ruanyifeng.com/#docs/proxy" target="_blank" rel="noopener" title="阮老师 《ECMAScript 6 入门》对proxy解释">链接地址</a></li><li>【译】Proxy及其优势：<a href="https://segmentfault.com/a/1190000019982184" target="_blank" rel="noopener">链接地址</a></li><li>Proxy 的巧用：<a href="https://juejin.im/post/5d2e657ae51d4510b71da69d#heading-0" target="_blank" rel="noopener">链接地址</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> ES6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> Proxy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Hexo+Github搭建你的个人博客</title>
      <link href="/2019/12/31/%E6%90%AD%E5%BB%BA%E4%BD%A0%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2019/12/31/%E6%90%AD%E5%BB%BA%E4%BD%A0%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="使用Hexo-Github搭建你的个人博客"><a href="#使用Hexo-Github搭建你的个人博客" class="headerlink" title="使用Hexo+Github搭建你的个人博客"></a>使用Hexo+Github搭建你的个人博客</h1><blockquote><p>作为一个合格的程序员，当然要有一个输入自己的博客，这不仅是学习很好的方法，也是面试中很能加分的一项！(PS:还阔以装😁)</p><blockquote><p>本篇文章介绍我是如何使用 <code>Hexo</code> + <code>Github</code> 来搭建我的博客。</p></blockquote></blockquote><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li><a href="https://github.com/" target="_blank" rel="noopener" title="Github地址">Gtihub</a> 账户我相信大家应该都用把，并且都会一些简单的操作；鉴于 <code>Gtihub</code> 是国外的服务器，有时候可能会因为网络的延迟造成加载很缓慢，也可以使用国内的 <a href="https://gitee.com/" target="_blank" rel="noopener" title="Gitee地址">Gitee</a> 或者 <a href="https://coding.net/" target="_blank" rel="noopener" title="Coding地址">Coding</a>。</li><li>安装 <a href="https://git-scm.com/download/win" target="_blank" rel="noopener" title="Git下载地址">Git</a>，Git是开源的分布式版本控制系统，用于敏捷高效地处理项目。我们网站在本地搭建好了，需要使用Git同步到GitHub上。</li><li>本机要有 <a href="https://nodejs.org/zh-cn/download/" target="_blank" rel="noopener" title="node下载地址">node</a> 环境。这个我相信做前端开发的，搭建vue项目等等操作，都是需要 <code>node</code>的支持。</li><li><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener" title="Hexo中文文档地址">Hexo</a> 的文章使用 <code>Markdown</code> 文件，建议没有看过简单写法的可以先去学习以下。</li></ul><blockquote><p>以上为基础操作，就不具体介绍了，如果有疑问可以在<a href="https://windows99.github.io/whoami/" title="首页关于我的界面">关于</a>菜单找到我的联系方式，或者百度谷歌。</p></blockquote><h2 id="创建-Github-仓库"><a href="#创建-Github-仓库" class="headerlink" title="创建 Github 仓库"></a>创建 Github 仓库</h2><ol><li>点击左边的按钮或者右上方+号，弹出下拉框，选择第一个。</li></ol><p>   <img src="http://pic.wsktop.com/images/2019/12/31/1.png" alt="创建仓库1"></p><ol start="2"><li>在第一个输入框仓库名要写成 你GitHub的用户名+ <code>.github.io</code>，这里我已经拥有了这个仓库，所以会报出一个错误！箭头指向的按钮要点击勾选，初始化仓库。</li></ol><p>   <img src="http://pic.wsktop.com/images/2019/12/31/2.png" alt="创建仓库2"></p><ol start="3"><li>创建完后会进入你的仓库，在工具栏找到 <code>Settings</code>，下滑找到 <code>Github Pages</code>，如下图：</li></ol><p>   <img src="http://pic.wsktop.com/images/2019/12/31/3.png" alt="选择GitHub Pages"></p><p>在 <code>Source</code> 下的下拉框，选中第一个选项，等一会，在上方就会有一个地址，可以通过这个地址访问你的博客。到这里仓库就算是创建完成了！</p><h2 id="本地搭建-Hexo"><a href="#本地搭建-Hexo" class="headerlink" title="本地搭建 Hexo"></a>本地搭建 Hexo</h2><p> Hexo就是我们的个人博客网站的框架 ，首先可以找到空白文件夹，安装好 <a href="https://git-scm.com/download/win" target="_blank" rel="noopener" title="Git下载地址">Git</a> 可以右击，点击 git bash，打开git命令行（或者window下使用cmd命令行）输入：</p><pre><code class="bash">npm install hexo-cli -g //  或者yarn add hexo-cli -g</code></pre><p>这个安装可能时间会有些长，耐心等待。如果在国内可以使用<a href="https://npm.taobao.org/" target="_blank" rel="noopener" title="淘宝NPM镜像地址">淘宝NPM镜像</a>。</p><p>安装完后，初始化我们的博客，输入：</p><pre><code class="bash">hexo init blog</code></pre><p>初始化完成后，进入文件夹，并安装依赖</p><pre><code class="bash">cd blognpm install //  或者yarn</code></pre><p>最后我们启动 <code>hexo</code> 服务：</p><pre><code class="bash">hexo server</code></pre><p>浏览器进入 <a href="http://localhost:4000/" target="_blank" rel="noopener" title="本地hexo服务地址">http://localhost:4000/</a>，可以看到 <code>hexo</code> 给我们的初始界面。到这里，我们本地就算是搭建好了，更多 <code>hexo</code>的配置和方法，请参考 <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener" title="Hexo中文文档">官网</a></p><h2 id="推送网站"><a href="#推送网站" class="headerlink" title="推送网站"></a>推送网站</h2><p>首先我们需要配置好站点配置文件，在hexo根目录下有一个 <code>_config.yml</code> 的文件，在themes文件夹，里面也有个 <code>_config.yml</code> 文件，这个被称为<strong>主题配置文件</strong>，这里我们打开站点配置文件。</p><p>翻到最后修改为：</p><pre><code class="yaml">deploy:  type: git  repo: [你的github仓库地址]  branch: [分支]  message: [提交信息]</code></pre><p>其实就是给 <code>hexo deploy</code> 这个命令做相应的配置，需要在根目录安装Git部署插件：</p><pre><code class="bash">npm install hexo-deployer-git --save//  或者yarn add hexo-deployer-git --save</code></pre><p>这时，我们输入：</p><pre><code class="bash">hexo clean &amp; hexo generatehexo deploy</code></pre><p>输入我们的GitHub账户密码，就与服务器相关联了！</p><p>md文件格式我会抽时间补一篇文章。hexo的编写建立大家先去查看 <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener" title="Hexo中文文档地址">官网</a>，已经很详细了！本文只是做个记录。最后在2019年最后一天，祝大家2020年新年快乐！</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> GitHub </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
