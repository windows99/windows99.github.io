<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>codewars Give me a Diamonds</title>
      <link href="/2020/06/12/codewars-Give-me-a-Diamonds/"/>
      <url>/2020/06/12/codewars-Give-me-a-Diamonds/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.codewars.com/kata/5503013e34137eeeaa001648/solutions/javascript" target="_blank" rel="noopener">题目：</a>杰米是个程序员，也是詹姆斯的女朋友。她喜欢钻石，想从詹姆斯那里得到一根钻石串。既然詹姆斯不知道怎么做，他需要你的帮助。</p><p>任务：您需要使用星号（*）字符返回在屏幕上打印时看起来像菱形的字符串。应删除尾随空格，并且每一行必须以换行符（\n）结尾。</p><p>返回null/nil/None/。。。如果输入是偶数或负数，则无法打印偶数或负数大小的钻石。</p><p>三颗钻石：</p><pre><code> **** *</code></pre><p>显示为 <code>&quot; *\n***\n *\n&quot;</code></p><p>五颗钻石：</p><pre><code>  * ******** ***  *</code></pre><p>显示为 <code>&quot; *\n ***\n*****\n ***\n *\n&quot;</code></p></blockquote><h1 id="第一次尝试"><a href="#第一次尝试" class="headerlink" title="第一次尝试"></a>第一次尝试</h1><pre><code class="javascript"> function diamond(n) {            if (n &gt; 1 &amp;&amp; n % 2 == 0) {                return null            }            let diam = &quot;&quot;            const digui = (e) =&gt; {                if (e == 1) {                    let arr = []                    for (let i = 0; i &lt; n / 2 - .5; i++) {                        arr.push(&quot; &quot;)                    }                    arr[arr.length] = &quot;*&quot;                    arr[arr.length + 1] = &quot;\n&quot;                    let a = arr.join(&quot;&quot;)                    if (n == 1) {                        diam = a                        return;                    }                    diam = a + diam + a                    return                } else if (e == n) {                    let arr = []                    for (let i = 0; i &lt; e; i++) {                        arr.push(&quot;*&quot;)                    }                    arr[arr.length + 1] = &quot;\n&quot;                    diam = arr.join(&quot;&quot;)                    digui(e - 2)                } else {                    let arr = []                    for (let i = 0; i &lt; (n - e) / 2; i++) {                        arr.push(&quot; &quot;)                    }                    for (let j = 0; j &lt; e; j++) {                        arr.push(&quot;*&quot;)                    }                    arr.push(&quot;\n&quot;)                    let a = arr.join(&quot;&quot;)                    diam = a + diam + a                    digui(e - 2)                }            }            digui(n)            return diam;        }</code></pre><p>结果是对的，但是测试报了溢出内存，于是请教了下有了第二版。</p><h1 id="第二次尝试"><a href="#第二次尝试" class="headerlink" title="第二次尝试"></a>第二次尝试</h1><pre><code class="js">        const diamond = n =&gt; {            if (n &lt; 1 || n % 2 == 0) {                return null            }            if (n == 1) {                return &quot;*\n&quot;            }            let arr = [],                diam = &quot;&quot;;            for (let i = 1; i &lt;= n; i += 2) {                arr.push(i)            }            let brr = [...arr]            let arrMax = brr.pop()            arrMax = (arrMax + 1) / 2;            arr = [...arr, ...brr.reverse()]            for (let j = 0; j &lt; arr.length; j++) {                arrMax--;                console.log(arrMax)                diam += &quot; &quot;.repeat(Math.abs(arrMax)) + &quot;*&quot;.repeat(arr[j]) + &quot;\n&quot;            }            return diam        }</code></pre><p>这次算是提交成功了，但是还不是很简洁，但是进去了就可以看到大佬的答案，(⊙﹏⊙)</p><h1 id="大佬的"><a href="#大佬的" class="headerlink" title="大佬的"></a>大佬的</h1><pre><code class="js">function diamond (n) {  if (n &lt;= 0 || n % 2 === 0) return null  str = &#39;&#39;  for (let i = 0; i &lt; n; i++) {     let len = Math.abs((n-2*i-1)/2)    str += &#39; &#39;.repeat(len)    str += &#39;*&#39;.repeat(n-2*len)    str += &#39;\n&#39;  }  return str}</code></pre><pre><code class="js">function diamond(n){  if (n &lt; 0 || !(n % 2)) return null;   const middleIndex = Math.floor(n / 2);  return Array.apply(null, {length: n})      .map((el, index) =&gt; {        const indentation = Math.abs(index - middleIndex);        const numberOfAsterisks = n - indentation * 2;        return Array(indentation + 1).join(&#39; &#39;) + Array(numberOfAsterisks + 1).join(&#39;*&#39;);      })      .join(&#39;\n&#39;) + &#39;\n&#39;;}</code></pre><pre><code class="js">function diamond(n){  if (n &lt; 0 || n % 2 == 0) return null;  for (var i = 0, diamond = &#39;&#39;; i &lt; n; i++) {    var stars = n - Math.abs(n - 2*i - 1);    var spaces = (n - stars) / 2;    while (spaces-- &gt; 0) diamond += &#39; &#39;;    while (stars-- &gt; 0) diamond += &#39;*&#39;;    diamond += &#39;\n&#39;;  }  return diamond;}</code></pre><p>给跪了，还需努力，加油！</p>]]></content>
      
      
      
        <tags>
            
            <tag> codewars </tag>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用谷歌浏览器调式app</title>
      <link href="/2020/06/11/%E4%BD%BF%E7%94%A8%E8%B0%B7%E6%AD%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E5%BC%8Fapp/"/>
      <url>/2020/06/11/%E4%BD%BF%E7%94%A8%E8%B0%B7%E6%AD%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E5%BC%8Fapp/</url>
      
        <content type="html"><![CDATA[<blockquote><p>​        通常我们在开发web端的时候，配合谷歌浏览器的开发者工具<code>F12</code>，可以查看控制台的输出内容，从而找到代码问题的所在，方便开发。</p><p>​        但是在安卓手机或者其他基于安卓系统的设备上，我们是无法直接查看控制台，聪明一点的可能会使用<code>alert</code>，但是这个东西并不是很方便，本篇文章讲述如何使用谷歌直接调式APP！</p></blockquote><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>要开始远程调试，你需要：</p><ul><li>安装 Chrome 32 或者之后的版本。</li><li>连接安卓设备用的 USB 线缆。</li><li>对于<strong>通过浏览器调试</strong>：安卓 4.0 以上并且安装了 <a href="https://play.google.com/store/apps/details?id=com.android.chrome&hl=en" target="_blank" rel="noopener">Chrome for Android</a>。</li><li>对于<strong>通过应用调试</strong>：安卓 4.4 以上并且应用包括<a href="https://developer.chrome.com/devtools/docs/remote-debugging#debugging-webviews" target="_blank" rel="noopener">可用于调试的</a> WenView 组件。</li></ul><h1 id="设置安卓设备"><a href="#设置安卓设备" class="headerlink" title="设置安卓设备"></a>设置安卓设备</h1><h2 id="打开USB调试选项"><a href="#打开USB调试选项" class="headerlink" title="打开USB调试选项"></a>打开USB调试选项</h2><p>在安卓设备上，进入设置=&gt;系统=&gt;开发者选项，找到USB调试。</p><p><strong>注意：在安卓4.2及以后的版本中，默认情况下开发者选项是隐藏的，要启用开发者选项，选择设置=&gt;关于手机然后点击版本号7次。</strong></p><p>在安卓上启用USB调试，之后会有一个警告，提示你是否要开启USB调试模式，选择<strong>确定</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/5771881-12a2be4718e0955b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/360/format/webp" alt="确定允许调式"></p><h2 id="连接你的设备"><a href="#连接你的设备" class="headerlink" title="连接你的设备"></a>连接你的设备</h2><p>将你的安卓设备和电脑使用USB线连接起来。</p><h1 id="在谷歌中找到设备"><a href="#在谷歌中找到设备" class="headerlink" title="在谷歌中找到设备"></a>在谷歌中找到设备</h1><p>在安卓设备上设置好远程调试后，在 Chrome 中找到你的设备。</p><p>在电脑端的 Chrome 里，在地址栏输入 <a href="chrome://inspect">chrome://inspect</a>。进入后确认 <strong>Discover USB devices</strong> 已经勾选了：</p><p><img src="https://upload-images.jianshu.io/upload_images/5771881-5102760af09a844a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/792/format/webp" alt="选择要调式的项目"></p><p>找到自己的项目，点击 <strong>inspect</strong>，首次加载可能会很慢，或者失败，需要搭个梯子，这部不做介绍。</p><p><img src="https://upload-images.jianshu.io/upload_images/5771881-2ab3849ca2ce743d.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="进入后样式"></p><p>然后就可以进去我们熟悉的画面了！简直不要太爽！</p>]]></content>
      
      
      
        <tags>
            
            <tag> APP </tag>
            
            <tag> 谷歌浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cordova免费开源的移动app开发</title>
      <link href="/2020/06/10/cordova%E5%85%8D%E8%B4%B9%E5%BC%80%E6%BA%90%E7%9A%84%E7%A7%BB%E5%8A%A8app%E5%BC%80%E5%8F%91/"/>
      <url>/2020/06/10/cordova%E5%85%8D%E8%B4%B9%E5%BC%80%E6%BA%90%E7%9A%84%E7%A7%BB%E5%8A%A8app%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<blockquote><p>​        近期接手了一个app的开发，因为项目是需要在手持机终端设备来进行的，有打印、NFC等功能。打印功能是厂家封装好的cordova插件，由于第一次接触，于是开始了边学边做的开发过程。</p></blockquote><h1 id="什么是-cordova"><a href="#什么是-cordova" class="headerlink" title="什么是 cordova"></a>什么是 <a href="https://cordova.axuer.com/" target="_blank" rel="noopener">cordova</a></h1><p>官网定义如下：</p><p>Apache Cordova是一个开源的移动开发框架。允许你用标准的web技术-HTML5,CSS3和JavaScript做跨平台开发。 应用在每个平台的具体执行被封装了起来，并依靠符合标准的API绑定去访问每个设备的功能，比如说：传感器、数据、网络状态等。</p><h1 id="安装-cordova"><a href="#安装-cordova" class="headerlink" title="安装 cordova"></a>安装 cordova</h1><p>cordova的命令运行在node.js上面并且可以通过npm进行安装。没有下载node的必须先下载<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">node</a>！</p><pre><code class="bash">npm install -g cordova</code></pre><p>安装完成后，可以使用cmd输入cordova回车，如果不报找不到，那么恭喜你第一步完成了。</p><h1 id="创建cordova工程"><a href="#创建cordova工程" class="headerlink" title="创建cordova工程"></a>创建cordova工程</h1><p>跳转到你项目的根目录，使用cmd或其他终端执行：</p><pre><code class="bash">cordova create path [id [name [config]]] [options]cordova create hello com.example.hello HelloWorld</code></pre><table><thead><tr><th>参数</th><th align="left">说明</th></tr></thead><tbody><tr><td>path</td><td align="left">不应该存在的目录。 Cordova将创建此目录</td></tr><tr><td>id</td><td align="left">默认：io.cordova.hellocordova<br />项目id，安卓中的java包名，ios的bundleID都需要用到这个，该值可以修改</td></tr><tr><td>name</td><td align="left">默认：HelloCordova<br />项目的name，安卓平台可能会使用该值作为类名，该值可以修改</td></tr><tr><td>config</td><td align="left">json字符串，其键/值将包含在<path> /.cordova/config.json中</td></tr></tbody></table><p>这会为你的cordova应用创建必须的目录</p><pre><code>myapp/|-- config.xml  ~~~~~~~~配置文件|-- hooks/    ~~~~~~~~~~一些build时的特殊脚本|-- www/   ~~~~~~~~~~~web内容|-- platforms/   ~~~~~~~原生平台代码| |-- android/| |-- windows/| |-- ios/|-- plugins/  ~~~~~~~~~~插件  |--cordova-plugin-camera/</code></pre><h1 id="添加平台"><a href="#添加平台" class="headerlink" title="添加平台"></a>添加平台</h1><p>给你的App添加目标平台。我们将会添加’ios’和’android’平台，并确保他们保存在了<code>config.xml</code>中:</p><pre><code class="bash">cordova platform add ios --savecordova platform add android --save</code></pre><p>检查你当前平台设置状况:</p><pre><code class="bash">cordova platform ls</code></pre><p><strong>注意:在你使用CLI创建应用的时候， <em>不要</em> 修改<code>/platforms/</code>目录中的任何文件。当准备构建应用或者重新安装插件时这个目录通常会被重写。</strong></p><h2 id="安卓平台安装要求-ios不做介绍"><a href="#安卓平台安装要求-ios不做介绍" class="headerlink" title="安卓平台安装要求(ios不做介绍)"></a><a href="[https://cordova.axuer.com/docs/zh-cn/latest/guide/platforms/android/index.html#%E5%AE%89%E8%A3%85%E8%A6%81%E6%B1%82](https://cordova.axuer.com/docs/zh-cn/latest/guide/platforms/android/index.html#安装要求)">安卓平台安装要求</a>(ios不做介绍)</h2><p>Cordova支持Android需要Android SDK，它可以安装在OS X, Linux和Windows上。查看 Android SDK的 <a href="http://developer.android.com/sdk/index.html#Requirements" target="_blank" rel="noopener">系统要求</a>. Cordova最新的Android包支持的是Android<a href="http://developer.android.com/guide/topics/manifest/uses-sdk-element.html#ApiLevels" target="_blank" rel="noopener">API-级别</a> 23。 最近几年 cordova-android支持的Android API-级别可以在下面这个表中看到:</p><table><thead><tr><th align="left">cordova-android 版本</th><th align="left">支持的 Android API-级别</th></tr></thead><tbody><tr><td align="left">5.X.X</td><td align="left">14 - 23</td></tr><tr><td align="left">4.1.X</td><td align="left">14 - 22</td></tr><tr><td align="left">4.0.X</td><td align="left">10 - 22</td></tr><tr><td align="left">3.7.X</td><td align="left">10 - 21</td></tr></tbody></table><h3 id="Java开发工具包-JDK"><a href="#Java开发工具包-JDK" class="headerlink" title="Java开发工具包(JDK)"></a>Java开发工具包(JDK)</h3><p>安装<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html" target="_blank" rel="noopener">Java Development Kit (JDK) 7</a>或者最新的。</p><p>当在Windows上安装的时候需要根据JDK路径设置<code>JAVA_HOME</code>环境变量(参见<a href="https://cordova.axuer.com/docs/zh-cn/latest/guide/platforms/android/index.html#setting-environment-variables" target="_blank" rel="noopener">设置环境变量</a>)</p><h3 id="Android-SDK"><a href="#Android-SDK" class="headerlink" title="Android SDK"></a>Android SDK</h3><p>安装<a href="http://developer.android.com/sdk/installing/index.html?pkg=tools" target="_blank" rel="noopener">Android Stand-alone SDK</a>或者<a href="http://developer.android.com/sdk/installing/index.html?pkg=studio" target="_blank" rel="noopener">Android Studio</a>。如果你计划开发一个新的Cordova Android插件或者使用Android平台原生的工具去运行和调试，那么就使用Android Studio吧。否则，Android Stand-alone SDK Tools就足够构建和部署Android应用程序了。</p><h3 id="添加SDK包"><a href="#添加SDK包" class="headerlink" title="添加SDK包"></a>添加SDK包</h3><p>在安装完Android SDK后,你需要安装任何你希望的目标<a href="http://developer.android.com/guide/topics/manifest/uses-sdk-element.html#ApiLevels" target="_blank" rel="noopener">API级别</a>的SDK包。建议你安装cordova-android(参见上面)支持的最高级别的SDK包。</p><p>打开Android SDK Manager (例如，在终端上运行`android)，并确保下面已经安装:</p><ol><li>目标Android版本的Android Platform SDK</li><li>Android SDK build-tools，版本19.1.0或者之上</li><li>Android Support Repository (在”Extras”查找)</li></ol><h3 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h3><p>为了使功能正常使用Cordova的CLI工具需要设置一些环境变量。CLI会尝试为你设置这些变量，但在某些情况下你需要手动设置。下面这些变量需要更新:</p><ol><li>设置<code>JAVA_HOME</code>环境变量，指定为JDK安装路径</li><li>设置<code>ANDROID_HOME</code>环境变量，指定为Android SDK安装路径</li><li>同时也建议你添加Android SDK的<code>tools</code>和<code>platform-tools</code>目录到你的<code>PATH</code></li></ol><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>这些步骤可能会因你安装的Windows版本而不同。在更改后，关闭并重新打开命令行提示符窗口，来看看他们的反应</p><ol><li>点击桌面左下角的<strong>开始</strong>菜单</li><li>在搜索栏中，搜索<strong>环境变量</strong>并从出现的选项中选择<strong>编辑系统的环境变量</strong></li><li>在出现的窗口中，点击<strong>环境变量</strong>按钮</li></ol><h4 id="创建一个新的环境变量"><a href="#创建一个新的环境变量" class="headerlink" title="创建一个新的环境变量:"></a>创建一个新的环境变量:</h4><ol><li>点击<strong>新建…</strong> 并输入变量的名字和值</li></ol><h4 id="T设置你的PATH"><a href="#T设置你的PATH" class="headerlink" title="T设置你的PATH:"></a>T设置你的<strong>PATH</strong>:</h4><ol><li><p>选择<strong>PATH</strong>变量并点击<strong>编辑</strong>。</p></li><li><p>添加条目到<strong>PATH</strong>相关的位置。 例如(用你本地的Android SDK安装路径替代路径):</p><pre><code>C:\Development\android-sdk\platform-toolsC:\Development\android-sdk\tools</code></pre></li></ol><h1 id="添加插件"><a href="#添加插件" class="headerlink" title="添加插件"></a>添加插件</h1><p>添加插件可以通过插件id和Git repo的url来添加:</p><pre><code>cordova plugin add cordova-plugin-xyprogress //通过插件idcordova plugin add https://github.com/cheerszhou/CordovaPulginForTest.git //通过Git url添加</code></pre><p>添加完插件后, 在项目目录的下<code>plugins/</code>会显示你添加的插件，而且config.xml中也会注册这些插件。</p><pre><code>cordova plugin rm cordova-plugin-xyprogress  // 插件删除cordova plugin ls  // 列举安装得插件</code></pre><h1 id="构建和运行"><a href="#构建和运行" class="headerlink" title="构建和运行"></a>构建和运行</h1><p>在构建之前，你需要检查你的开发环境是否搭建好了？</p><pre><code class="bash">cordova requirements</code></pre><p>使用 <code>Cordova build</code> 构建所有平台，也可以指定构建平台：</p><pre><code>cordova build android</code></pre><p>使用 <code>cordova run</code> 来构建并运行所有平台，也可以使用下面带选项得命令：</p><ul><li>在Android平台上,名为Nexus_5_API_23_x86模拟器上运行的当前cordova项目的发布版本. 运行时使用特定构建配置：</li></ul><pre><code class="undefined">cordova run android --release --buildConfig=..\myBuildConfig.json --target=Nexus_5_API_23_x86</code></pre><ul><li>使用真机或模拟器（如果没有连接设备）在Android平台上运行当前cordova项目的调试版本. 跳过构建：</li></ul><pre><code class="undefined">cordova run android --nobuild</code></pre><ul><li>在ios设备上运行当前cordova项目的调试版本：</li></ul><pre><code class="undefined">cordova run ios --device</code></pre><ul><li>枚举可用于运行此应用程序的所有连接设备和可用模拟器的名称：</li></ul><pre><code class="cpp">cordova run ios --list</code></pre><ul><li>或者模拟器中运行:</li></ul><pre><code class="bash">cordova emulate ios//指定模拟器使用的模拟设备:cordova emulate ios --target iPhone-6scordova emulate ios --target iPhone-6s-Plus</code></pre><h1 id="调式和测试"><a href="#调式和测试" class="headerlink" title="调式和测试"></a>调式和测试</h1><p>由于app安装在安卓设备里，无法像浏览器一样使用控制台进行输出调试。但是可以使用谷歌的手机调式：</p><p><a href="[chrome://inspect/#devices](chrome://inspect/#devices)">点击这个链接</a>进入谷歌界面，手机USB连接你的电话，要打开USB调式模式，使用运行或者打包就可以在这个界面看到我们的设备，并显示要调式的app，这样就可以查看控制台进行调试了！</p>]]></content>
      
      
      
        <tags>
            
            <tag> APP </tag>
            
            <tag> cordova </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器输入url到显示页面的过程</title>
      <link href="/2020/03/09/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5url%E5%88%B0%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
      <url>/2020/03/09/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5url%E5%88%B0%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="DNS解析，将域名地址解析为IP地址"><a href="#DNS解析，将域名地址解析为IP地址" class="headerlink" title="DNS解析，将域名地址解析为IP地址"></a>DNS解析，将域名地址解析为IP地址</h1><ul><li>浏览器DNS缓存</li><li>系统DNS缓存</li><li>路由器DNS缓存</li><li>运营商DNS缓存</li><li>再找不到就递归搜索该网址</li></ul><h1 id="如果找到了，就会TCP连接"><a href="#如果找到了，就会TCP连接" class="headerlink" title="如果找到了，就会TCP连接"></a>如果找到了，就会TCP连接</h1><h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h2><ul><li>第一次握手，有浏览器发起，告诉服务器，我要发送请求了</li><li>第二次握手，由服务器发起，告诉浏览器我准备接受了，你发送吧</li><li>第三次握手，由浏览器发送，告诉服务器，我马上发送了，准备接受吧</li></ul><h1 id="发送请求报文"><a href="#发送请求报文" class="headerlink" title="发送请求报文"></a>发送请求报文</h1><ul><li>发送HTTP协议的通信内容，即请求报文</li></ul><h1 id="接受响应"><a href="#接受响应" class="headerlink" title="接受响应"></a>接受响应</h1><ul><li>响应报文</li></ul><h1 id="渲染页面"><a href="#渲染页面" class="headerlink" title="渲染页面"></a>渲染页面</h1><ul><li>遇见HTML标记，浏览器调用    HTML解析器解析成Token，并构建成DOM树</li><li>遇见style/link标记，浏览器调用css解析器</li><li>遇见script标记，调用javascript解析器，处理script代码（绑定时间，修改dom树/css dom树）</li><li>根据渲染树计算布局，计算每个节点的几何信息（布局）</li><li>将各个节点颜色绘制到屏幕上（渲染）</li></ul><p><strong>注意这5个步骤不一定按顺序执行，如果dom树或cssdom树被修改了，可能会执行多次布局和渲染</strong></p><h1 id="断开连接"><a href="#断开连接" class="headerlink" title="断开连接"></a>断开连接</h1><ul><li>第一次挥手，浏览器发起，发送给服务器，我东西发送完了（请求报文），你准备关闭吧</li><li>第二次挥手，服务器发起，告诉浏览器，我东西接受完了（请求报文），我准备关闭了，你也准备吧</li><li>第三次挥手，服务器发起，告诉浏览器，我东西发送完了（响应报文），你准备关闭吧</li><li>第四次挥手，浏览器发起，告诉服务器，我东西接收完了，我准备关闭了，你也准备吧</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flex布局</title>
      <link href="/2020/02/05/flex%E5%B8%83%E5%B1%80/"/>
      <url>/2020/02/05/flex%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​        最初的布局是使用 <code>table</code> 表格布局，后来是基于盒模型，依赖 <code>display</code> 属性 + <code>position</code> 属性 + <code>float</code> 属性。它对于那些特殊布局非常不方便，比如垂直居中就很不容易实现。 </p><p>​        于是，W3C在2009年提出了一种新的方案——flex布局，可以简便、完整、响应式地实现各种布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能安全地使用这项功能。</p><p><img src="https://www.runoob.com/wp-content/uploads/2015/07/8712d713c7d0b884a5cb9770efc422b4.jpg" alt="浏览器兼容性"></p><h1 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h1><p><code>Flex</code> 英文意思为：弯曲、屈伸、可以伸缩的布局，天生就是为了适配不同的分辨率。</p><pre><code class="css">.flex-container{    dispaly: flex;}</code></pre><p>设置完 <code>flex</code> 之后，就会有下面的关系图，我们来看下：</p><p><img src="https://www.runoob.com/wp-content/uploads/2015/07/3791e575c48b3698be6a94ae1dbff79d.png" alt="flex关系图"></p><p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）；<br>主轴的开始位置（与边框交叉点）叫做main start，结束位置叫做main end；<br>交叉轴的开始位置叫做cross start，结束位置叫做cross end；<br>项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。</p><h1 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h1><p>简单而言，谁被设置了 <code>display：flex</code> ，谁就是容器。容器属性要写到容器里！分为一下6个属性：</p><ol><li>flex-direction</li><li>flex-wrap</li><li>flex-flow</li><li>justify-content</li><li>align-items</li><li>align-content</li></ol><h2 id="flex-direction属性"><a href="#flex-direction属性" class="headerlink" title="flex-direction属性"></a>flex-direction属性</h2><p>flex-direction属性决定主轴的方向。</p><pre><code class="css">.flex-container{    flex-direction: row | row-reverse | column | column-reverse | initial | inherit;}</code></pre><p><img src="https://www.runoob.com/wp-content/uploads/2015/07/0cbe5f8268121114e87d0546e53cda6e.png" alt="flex-direction"></p><ol><li>row（默认）：主轴水平方向，起点在左端；</li><li>row-reverse：主轴为水平方向，起点在右端。</li><li>column：主轴为垂直方向，起点在上沿。</li><li>column-reverse：主轴为垂直方向，起点在下沿。</li><li>initial：意为“最初的”，是CSS提供的关键字，设置某个属性的默认值。</li><li>inherit：意为“继承”，可以从父元素继承该属性。</li></ol><h2 id="flex-wrap属性"><a href="#flex-wrap属性" class="headerlink" title="flex-wrap属性"></a>flex-wrap属性</h2><p>flex-wrap属性决定如何换行。</p><pre><code class="css">.flex-container{    flex-wrap: nowrap | wrap | wrap-reverse;}</code></pre><p><img src="https://img-blog.csdnimg.cn/20200601144824720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VjYkpT,size_16,color_FFFFFF,t_70" alt="flex-wrap"></p><ol><li>nowarp（默认）：不换行。</li><li>warp：换行，第一行在上方。</li><li>warp-reverse：换行，第一行在下方。</li></ol><h2 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h2><p>flex-flow属性是 <code>flex-direction</code> 和 <code>flex-warp</code> 属性的简写，默认为row nowrap。</p><pre><code class="css">.flex-container{    flex-flow: &lt;flex-direction&gt; &lt;flex-warp&gt;;}</code></pre><h2 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h2><p>justify-content属性控制主轴的对齐方式。</p><pre><code class="css">.flex-container{     justify-content: flex-start | flex-end | center | space-between | space-around;}</code></pre><p><img src="https://img-blog.csdnimg.cn/20200601150225317.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VjYkpT,size_16,color_FFFFFF,t_70" alt="justify-content"></p><ol><li>flex-start（默认值）：左对齐。</li><li>flex-end：右对齐。</li><li>center：居中。</li><li>space-between：两端对齐，项目之间的间隔都相等。</li><li>space-around：每个项目两侧的间隔相等。所以项目之间的间隔比项目与边框的间隔大一倍。</li></ol><h2 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h2><p>align-items属性控制交叉轴的对齐方式。</p><pre><code class="css">.flex-container {    align-items: flex-start | flex-end | center | baseline | stretch;}</code></pre><p><img src="https://img-blog.csdnimg.cn/2020060115230852.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VjYkpT,size_16,color_FFFFFF,t_70" alt="align-items"></p><ol><li>flex-start：交叉轴的起点对齐。</li><li>flex-end：交叉轴的终点对齐。</li><li>center：交叉轴的中点对齐。</li><li>baseline: 项目的第一行文字的基线对齐。</li><li>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li></ol><h2 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h2><p>align-content属性控制了多跟轴线的对齐方式，如果项目只有一根轴线，该属性不起作用。</p><pre><code class="css">.flex-container{    align-content: flex-start | flex-end | center | space-between | space-around | stretch;}</code></pre><p><img src="https://img-blog.csdnimg.cn/20200601154350846.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VjYkpT,size_16,color_FFFFFF,t_70" alt="align-content"></p><ol><li>flex-start：与交叉轴的起点对齐。</li><li>flex-end：与交叉轴的终点对齐。</li><li>center：与交叉轴的中点对齐。</li><li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</li><li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li><li>stretch（默认值）：轴线占满整个交叉轴。</li></ol><h1 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h1><ol><li>order</li><li>flex-grow</li><li>flex-shrink</li><li>flex-basis</li><li>flex</li><li>align-self</li></ol><h2 id="order"><a href="#order" class="headerlink" title="order"></a>order</h2><p>order属性设置项目的排列顺序，从小到大，数值越小，排列越靠前，默认为0。</p><pre><code class="css">.item{    order: &lt;integer&gt;;}</code></pre><p><img src="https://img-blog.csdnimg.cn/20200601155120966.png" alt="order"></p><h2 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h2><p>flex-grow定义项目的放大比例，默认为0，不参与放大。</p><pre><code class="css">.item{    flex-grow: &lt;number&gt;; /* default 0 */}</code></pre><p><img src="https://img-blog.csdnimg.cn/20200601155655925.png" alt="flex-grow"></p><h2 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h2><p>flex-shrink定义项目的缩放。</p><pre><code class="css">.item{    flex-shrink: &lt;number&gt;; /* default 1 */}</code></pre><p><img src="https://img-blog.csdnimg.cn/20200602114634533.png" alt="flex-shrink"></p><h2 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h2><p>flex-basis定义了在分配多余空间之前，项目占据的主轴空间。</p><pre><code class="css">.item{    flex-basis:  &lt;number&gt; | auto; /* default auto */}</code></pre><h2 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h2><p>flex属性是 <code>flex-grow</code> 、<code>flex-shrink</code> 、<code>flex-basis</code> 的简写。</p><pre><code class="css">.item {     flex: none | [ &lt;&#39;flex-grow&#39;&gt; &lt;&#39;flex-shrink&#39;&gt;? || &lt;&#39;flex-basis&#39;&gt; ]}</code></pre><h2 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h2><p>align-self属性允许子元素单独的对齐方式。默认为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</p><pre><code class="css">.item {    align-self: auto | flex-start | flex-end | center | baseline | stretch;}</code></pre><p><img src="https://img-blog.csdnimg.cn/2020060211563922.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VjYkpT,size_16,color_FFFFFF,t_70" alt="align-self"></p><h1 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h1><p>​        flex 布局是轴线布局，只能指定”项目“针对轴线的位置，可以看作是 <code>一维布局</code> 。grid网格布局是将容器划分成”行“和”列“，产生单元格，然后指定“项目所在”的单元格，可以看作是二维布局。gird布局远比flex布局强大，是最强大的css布局解决方案。</p><p>​        下期我们谈谈grid布局。感谢！</p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> flex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack-初探</title>
      <link href="/2020/01/06/webpack-%E5%88%9D%E6%8E%A2/"/>
      <url>/2020/01/06/webpack-%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<blockquote><p><code>webpack</code> 将程序员编写的源代码，经过压缩、编译、语法检查等一系列操作，编译成浏览器可以识别的代码，优化性能。</p></blockquote><h1 id="Webpack基本介绍"><a href="#Webpack基本介绍" class="headerlink" title="Webpack基本介绍"></a>Webpack基本介绍</h1><h2 id="概念的引入"><a href="#概念的引入" class="headerlink" title="概念的引入"></a>概念的引入</h2><p>在网页中，我们经常会引入<code>JS</code> <code>CSS</code> <code>Img</code> <code>Fonts</code> <code>vue</code> 等这类的静态资源，这个时候我们来了两个问题：</p><ol><li><code>vue</code> <code>ejs</code> 等文件以及 <code>es6</code>的新语法、模块化开发浏览器读不懂啊！</li><li>网页加载速度慢，要多次重复的发生资源请求！</li></ol><p>如何解决这两个问题呢？别急，这个时候<code>webpack</code>的作用就来了！</p><h2 id="什么是Webpack"><a href="#什么是Webpack" class="headerlink" title="什么是Webpack"></a>什么是Webpack</h2><p>Webpack是一个前端的模块打包器，基于node开发出来的一个前端工具，将前端所有静态资源都当作模块处理。</p><h2 id="Webpack支持的规范"><a href="#Webpack支持的规范" class="headerlink" title="Webpack支持的规范"></a>Webpack支持的规范</h2><ol><li>ES6规范</li><li>CommonJS规范</li><li>AMD规范</li><li>CMD规范</li></ol><h1 id="Webpack基本使用"><a href="#Webpack基本使用" class="headerlink" title="Webpack基本使用"></a>Webpack基本使用</h1><h2 id="创建基本目录结构"><a href="#创建基本目录结构" class="headerlink" title="创建基本目录结构"></a>创建基本目录结构</h2><p>在 <code>CMD</code> 中运行：</p><pre><code class="bash">mkdir webpackcd webpacknpm init</code></pre><p>可以直接通过<code>CMD</code> 创建简单的文件，也可以直接创建：</p><pre><code class="powershell">type nul&gt;index.htmltype nul&gt;index.jstype nul&gt;webpack.config.js</code></pre><p><strong>index.html:</strong></p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;    &lt;title&gt;webpack-初探&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;script src=&quot;./dist/main.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>这里<strong>html</strong>里引入的 main.js 现在是没有的，一会将会把index.js 打包成 dist下的 mian.js</p><p><strong>index.js:</strong></p><pre><code class="js">console.log(&#39;webapck-初探&#39;);</code></pre><h2 id="安装Webpack"><a href="#安装Webpack" class="headerlink" title="安装Webpack"></a>安装Webpack</h2><p>在开始之前，请确保安装了<code>Node.js</code>的最新版本，使用旧版本，你可能遇到各种问题，因为它们可能缺少 webpack 功能以及/或者缺少相关 package 包。</p><p>要安装最新版本或特定版本，请运行以下命运之一：</p><pre><code class="bash">npm install --save-dev webpacknpm install --save-dev webpack@&lt;version&gt;</code></pre><p>如果你使用webpack 4+ 版本，你还需要安装 CLI。</p><pre><code class="bash">npm install --save-dev webpack-cli</code></pre><p>你也可以全局安装，这样就能在全局使用<code>webpack</code>命令，但是官方不推荐全局安装webpack。这会将你项目中的 webpack 锁定到指定版本，并且在使用不同的webpack版本项目中，可能会导致<strong>构建失败</strong>。</p><pre><code class="bash">npm install --global webpacknpm install --global webpack-cli</code></pre><h2 id="Webpack基本配置"><a href="#Webpack基本配置" class="headerlink" title="Webpack基本配置"></a>Webpack基本配置</h2><p>在<code>webpack.config.js</code>里写入：</p><pre><code class="javascript">const path = require(&#39;path&#39;);module.exports = {    entry: &#39;./index.js&#39;,   //  入口文件    output: {   //  出口文件配置        path: path.resolve(__dirname, &#39;dist&#39;),        filename: &#39;main.js&#39;,    },    mode: &#39;development&#39;,  //  模式：开发 development   生产 production}</code></pre><p>配置好后命令行敲入：</p><pre><code class="bash">webpack</code></pre><p>该命令会自动寻找根目录下的<code>webpack.config.js</code>，根据配置进行打包，这个时候我们就可以看到根目录多了<code>dist</code>目录，里面有一个<strong>main.js</strong>。</p><h1 id="Webpack四大核心"><a href="#Webpack四大核心" class="headerlink" title="Webpack四大核心"></a>Webpack四大核心</h1><h2 id="入口-entry"><a href="#入口-entry" class="headerlink" title="入口(entry)"></a>入口(entry)</h2><p><strong>入口起点</strong>指示 webpack 应该使用哪个模块，来作为构建内部<em>依赖图</em>的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和简介）依赖的。</p><p> 每个依赖项随即被处理，最后输出到称之为 <em>bundles</em> 的文件中，我们将在下一章节详细讨论这个过程。 </p><p>可以通过在 <a href="https://www.webpackjs.com/configuration" target="_blank" rel="noopener">webpack 配置</a>中配置 <code>entry</code> 属性，来指定一个入口起点（或多个入口起点）。默认值为 <code>./src</code>。 </p><p>接下来我们看一个简单的例子：</p><pre><code class="javascript">module.exports = {  entry: &#39;./path/to/my/entry/file.js&#39;};</code></pre><h2 id="出口-output"><a href="#出口-output" class="headerlink" title="出口(output)"></a>出口(output)</h2><p><strong>output</strong> 属性告诉 webpack 在哪里输出它所创建的 <em>bundles</em>，以及如何命名这些文件，默认值为 <code>./dist</code>。基本上，整个应用程序结构，都会被编译到你指定的输出路径的文件夹中。你可以通过在配置中指定一个 <code>output</code> 字段，来配置这些处理过程：</p><pre><code class="javascript">const path = require(&#39;path&#39;);module.exports = {  entry: &#39;./path/to/my/entry/file.js&#39;,  output: {    path: path.resolve(__dirname, &#39;dist&#39;),    filename: &#39;my-first-webpack.bundle.js&#39;  }};</code></pre><p>在上面的示例中，我们通过 <code>output.filename</code> 和 <code>output.path</code> 属性，来告诉 webpack bundle 的名称，以及我们想要 bundle 生成(emit)到哪里。可能你想要了解在代码最上面导入的 path 模块是什么，它是一个 <a href="https://nodejs.org/api/modules.html" target="_blank" rel="noopener">Node.js 核心模块</a>，用于操作文件路径。</p><h2 id="·loader"><a href="#·loader" class="headerlink" title="·loader"></a>·loader</h2><p><em>loader</em> 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效<a href="https://www.webpackjs.com/concepts/modules" target="_blank" rel="noopener">模块</a>，然后你就可以利用 webpack 的打包能力，对它们进行处理。</p><p>本质上，webpack loader 将所有类型的文件，转换为应用程序的依赖图（和最终的 bundle）可以直接引用的模块。</p><blockquote><p>注意，loader 能够 <code>import</code> 导入任何类型的模块（例如 <code>.css</code> 文件），这是 webpack 特有的功能，其他打包程序或任务执行器的可能并不支持。我们认为这种语言扩展是有很必要的，因为这可以使开发人员创建出更准确的依赖关系图。</p></blockquote><p>在更高层面，在 webpack 的配置中 <strong>loader</strong> 有两个目标：</p><ol><li><code>test</code> 属性，用于标识出应该被对应的 loader 进行转换的某个或某些文件。</li><li><code>use</code> 属性，表示进行转换时，应该使用哪个 loader。</li></ol><pre><code class="javascript">const path = require(&#39;path&#39;);const config = {  output: {    filename: &#39;my-first-webpack.bundle.js&#39;  },  module: {    rules: [      { test: /\.txt$/, use: &#39;raw-loader&#39; }    ]  }};module.exports = config;</code></pre><p>以上配置中，对一个单独的 module 对象定义了 <code>rules</code> 属性，里面包含两个必须属性：<code>test</code> 和 <code>use</code>。这告诉 webpack 编译器(compiler) 如下信息：</p><blockquote><p>“嘿，webpack 编译器，当你碰到「在 <code>require()</code>/<code>import</code> 语句中被解析为 ‘.txt’ 的路径」时，在你对它打包之前，先<strong>使用</strong> <code>raw-loader</code> 转换一下。”</p></blockquote><h2 id="插件-plugins"><a href="#插件-plugins" class="headerlink" title="插件(plugins)"></a>插件(plugins)</h2><p>loader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。<a href="https://www.webpackjs.com/api/plugins" target="_blank" rel="noopener">插件接口</a>功能极其强大，可以用来处理各种各样的任务。</p><p>想要使用一个插件，你只需要 <code>require()</code> 它，然后把它添加到 <code>plugins</code> 数组中。多数插件可以通过选项(option)自定义。你也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 <code>new</code> 操作符来创建它的一个实例。</p><p><strong>webpack.config.js</strong></p><pre><code class="javascript">const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;); // 通过 npm 安装const webpack = require(&#39;webpack&#39;); // 用于访问内置插件const config = {  module: {    rules: [      { test: /\.txt$/, use: &#39;raw-loader&#39; }    ]  },  plugins: [    new HtmlWebpackPlugin({template: &#39;./src/index.html&#39;})  ]};module.exports = config;</code></pre><h1 id="webpack-dev-server的使用"><a href="#webpack-dev-server的使用" class="headerlink" title="webpack-dev-server的使用"></a>webpack-dev-server的使用</h1><p>每次改完代码，都需要手动执行<code>webpack</code>命令打包编译文件，比较繁琐；这个时候我们可以使用热加载：</p><h2 id="安装webpack-dev-server："><a href="#安装webpack-dev-server：" class="headerlink" title="安装webpack-dev-server："></a>安装<code>webpack-dev-server</code>：</h2><pre><code class="javascript">npm install webpack-dev-server -D</code></pre><h2 id="在webpack-config-js中配置："><a href="#在webpack-config-js中配置：" class="headerlink" title="在webpack.config.js中配置："></a>在<code>webpack.config.js</code>中配置：</h2><pre><code class="js">const path = require(&#39;path&#39;);const webpack = require(&#39;webpack&#39;);module.exports = {    entry: &#39;./js/a.js&#39;,    output: {        path: path.resolve(__dirname, &#39;dist&#39;),        filename: &#39;main.js&#39;,    },    mode: &#39;development&#39;,    devServer: {      contentBase: &#39;./&#39;,      compress: true,      port: 9000,         hot: true    },    plugins: [        new webpack.NamedModulesPlugin(),        new webpack.HotModuleReplacementPlugin()    ],}</code></pre><h2 id="在package-json里面的scripts属性里面添加webpack-dev-server命令到开发环境"><a href="#在package-json里面的scripts属性里面添加webpack-dev-server命令到开发环境" class="headerlink" title="在package.json里面的scripts属性里面添加webpack-dev-server命令到开发环境"></a>在<code>package.json</code>里面的<code>scripts</code>属性里面添加<code>webpack-dev-server</code>命令到开发环境</h2><pre><code class="js">&quot;scripts&quot;: {    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,    &quot;dev&quot;: &quot;webpack-dev-server&quot;  },</code></pre><h2 id="执行npm-run-dev"><a href="#执行npm-run-dev" class="headerlink" title="执行npm run dev:"></a>执行<code>npm run dev</code>:</h2><pre><code class="bash">npm run dev</code></pre><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p><code>Webpack</code>是大家必须要学习的一项工具，本篇文章就暂且结束了，后面我会更新如何打包css、img，按需加载以及一些插件使用了；</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.webpackjs.com/concepts/" target="_blank" rel="noopener">Webpack官网</a></li><li><a href="https://juejin.im/post/5d2fd19be51d4576bc1a0eb0#heading-13" target="_blank" rel="noopener">Webpack基本使用</a></li><li><a href="https://juejin.im/post/5b59d83de51d45195f0b4790" target="_blank" rel="noopener">Webpack入门教程</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> webpack </tag>
            
            <tag> 前端打包工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对ES6-proxy的理解</title>
      <link href="/2020/01/05/%E5%AF%B9ES6-proxy%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2020/01/05/%E5%AF%B9ES6-proxy%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>ES6(ECMAScript2015) 是 <code>JavaScript</code> 一个版本标准，作为前端爱好者是必须要掌握的，本篇记录我对ES6中，<code>proxy</code> 的理解。</p></blockquote><h1 id="字面理解"><a href="#字面理解" class="headerlink" title="字面理解"></a>字面理解</h1><p><code>Proxy</code> 在英语中是代理的意思，那我们就引发了几个疑问：</p><ol><li>它代理了什么？</li><li>为什么要代理？</li><li>如何使用代理？</li></ol><p>首先我们引用阮老师的 <code>《ECMAScript 6 入门》</code> 书籍中的概述：</p><blockquote><p>Proxy 可以理解成，在<strong>目标对象</strong>之前架设一层“拦截器”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p></blockquote><p>那么通过阮老师的这句话，我们可以得出第一个问题的答案：</p><p><strong>它代理了对象</strong></p><h1 id="为什么要代理"><a href="#为什么要代理" class="headerlink" title="为什么要代理"></a>为什么要代理</h1><p>第二个问题是为什么要使用 <code>proxy</code>？我总结了以下几点：</p><ul><li>拦截和监视外部对象的访问</li><li>降低函数或类的复杂度</li><li>在复杂操作前对操作进行校验或对所需资源进行管理</li></ul><p>先来一个不使用 <code>proxy</code> 的栗子：</p><pre><code class="js">let user = {    name: &#39;John&#39;,    surname: &#39;Doe&#39;};let printUser = (property) =&gt; {    let value = user[property];    if (!value) {        throw new Error(`The property [${property}] does not exist`);    } else {        console.log(`The user ${property} is ${value}`);    }}printUser(&#39;name&#39;); // 输出: &#39;The user name is John&#39;printUser(&#39;email&#39;); // 抛出错误: The property [email] does not exist</code></pre><p>这是一个简单的例子，我们有一个带有几个属性的用户对象，如果属性存在，我们想要打印用户信息，如果不存在，则抛出异常。通过上面的代码，你会发现：将条件和异常移到其他地方，而 <code>printUser</code> 中仅关注显示用户信息的实际逻辑会更好。这是我们可以使用代理对象的地方，让我们更新下这个例子。</p><pre><code class="javascript">let user = {    name: &#39;John&#39;,    surname: &#39;Doe&#39;};let proxy = new Proxy(user, {    get(target, property) {        let value = target[property];        if (!value) {            throw new Error(`The property [${property}] does not exist`);        }        return value;    }});let printUser = (property) =&gt; {    console.log(`The user ${property} is ${proxy[property]}`);};printUser(&#39;name&#39;); // 输出： &#39;The user name is John&#39;printUser(&#39;email&#39;); // 抛出错误: The property [email] does not exist</code></pre><p>在上面的示例中，我们包装了 <code>user</code> 对象，并设置了一个 <code>get</code> 方法。此方法充当拦截器，在返回值之前，会首先对属性值进行检查，如果不存在，则抛出异常。</p><p>输出与第一种情况相同，但此时 <code>printUser</code> 函数专注于逻辑，只处理消息。</p><h1 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h1><p>proxy除了代理get，set操作，还能代理其他的操作，如下：</p><pre><code class="js">handler.getPrototypeOf()// 在读取代理对象的原型时触发该操作，比如在执行 Object.getPrototypeOf(proxy) 时。handler.setPrototypeOf()// 在设置代理对象的原型时触发该操作，比如在执行 Object.setPrototypeOf(proxy, null) 时。handler.isExtensible()// 在判断一个代理对象是否是可扩展时触发该操作，比如在执行 Object.isExtensible(proxy) 时。handler.preventExtensions()// 在让一个代理对象不可扩展时触发该操作，比如在执行 Object.preventExtensions(proxy) 时。handler.getOwnPropertyDescriptor()// 在获取代理对象某个属性的属性描述时触发该操作，比如在执行 Object.getOwnPropertyDescriptor(proxy, &quot;foo&quot;) 时。handler.defineProperty()// 在定义代理对象某个属性时的属性描述时触发该操作，比如在执行 Object.defineProperty(proxy, &quot;foo&quot;, {}) 时。handler.has()// 在判断代理对象是否拥有某个属性时触发该操作，比如在执行 &quot;foo&quot; in proxy 时。handler.get()// 在读取代理对象的某个属性时触发该操作，比如在执行 proxy.foo 时。handler.set()// 在给代理对象的某个属性赋值时触发该操作，比如在执行 proxy.foo = 1 时。handler.deleteProperty()// 在删除代理对象的某个属性时触发该操作，比如在执行 delete proxy.foo 时。handler.ownKeys()// 在获取代理对象的所有属性键时触发该操作，比如在执行 Object.getOwnPropertyNames(proxy) 时。handler.apply()// 在调用一个目标对象为函数的代理对象时触发该操作，比如在执行 proxy() 时。handler.construct()// 在给一个目标对象为构造函数的代理对象构造实例时触发该操作，比如在执行new proxy() 时。</code></pre><h1 id="proxy栗子"><a href="#proxy栗子" class="headerlink" title="proxy栗子"></a>proxy栗子</h1><p>通过属性查找数组中的特定对象</p><p>以下代理为数组扩展了一些实用工具，可一看到，你可以灵活地“定义”属性，而不需要使用 <code>Object.defineProperties</code> 方法。</p><pre><code class="javascript">let products = new Proxy([  { name: &#39;Firefox&#39;, type: &#39;browser&#39; },  { name: &#39;SeaMonkey&#39;, type: &#39;browser&#39; },  { name: &#39;Thunderbird&#39;, type: &#39;mailer&#39; }],{  get: function(obj, prop) {    // 缺省行为是返回属性值， prop ?通常是一个整数    if (prop in obj) {      return obj[prop];    }    // 获取 products 的 number; 它是 products.length 的别名    if (prop === &#39;number&#39;) {      return obj.length;    }    let result, types = {};    for (let product of obj) {      if (product.name === prop) {        result = product;      }      if (types[product.type]) {        types[product.type].push(product);      } else {        types[product.type] = [product];      }    }    // 通过 name 获取 product    if (result) {      return result;    }    // 通过 type 获取 products    if (prop in types) {      return types[prop];    }    // 获取 product type    if (prop === &#39;types&#39;) {      return Object.keys(types);    }    return undefined;  }});console.log(products[0]); // { name: &#39;Firefox&#39;, type: &#39;browser&#39; }console.log(products[&#39;Firefox&#39;]); // { name: &#39;Firefox&#39;, type: &#39;browser&#39; }console.log(products[&#39;Chrome&#39;]); // undefinedconsole.log(products.browser); // [{ name: &#39;Firefox&#39;, type: &#39;browser&#39; }, { name: &#39;SeaMonkey&#39;, type: &#39;browser&#39; }]console.log(products.types); // [&#39;browser&#39;, &#39;mailer&#39;]console.log(products.number); // 3</code></pre><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li>MDN官网对 <code>proxy</code> 的解释： <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener" title="mdn官网对proxy解释">链接地址</a></li><li>阮老师 《ECMAScript 6 入门》 对 <code>proxy</code> 的解释： <a href="http://es6.ruanyifeng.com/#docs/proxy" target="_blank" rel="noopener" title="阮老师 《ECMAScript 6 入门》对proxy解释">链接地址</a></li><li>【译】Proxy及其优势：<a href="https://segmentfault.com/a/1190000019982184" target="_blank" rel="noopener">链接地址</a></li><li>Proxy 的巧用：<a href="https://juejin.im/post/5d2e657ae51d4510b71da69d#heading-0" target="_blank" rel="noopener">链接地址</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> ES6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> Proxy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Hexo+Github搭建你的个人博客</title>
      <link href="/2019/12/31/%E6%90%AD%E5%BB%BA%E4%BD%A0%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2019/12/31/%E6%90%AD%E5%BB%BA%E4%BD%A0%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="使用Hexo-Github搭建你的个人博客"><a href="#使用Hexo-Github搭建你的个人博客" class="headerlink" title="使用Hexo+Github搭建你的个人博客"></a>使用Hexo+Github搭建你的个人博客</h1><blockquote><p>作为一个合格的程序员，当然要有一个输入自己的博客，这不仅是学习很好的方法，也是面试中很能加分的一项！(PS:还阔以装😁)</p><blockquote><p>本篇文章介绍我是如何使用 <code>Hexo</code> + <code>Github</code> 来搭建我的博客。</p></blockquote></blockquote><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li><a href="https://github.com/" target="_blank" rel="noopener" title="Github地址">Gtihub</a> 账户我相信大家应该都用把，并且都会一些简单的操作；鉴于 <code>Gtihub</code> 是国外的服务器，有时候可能会因为网络的延迟造成加载很缓慢，也可以使用国内的 <a href="https://gitee.com/" target="_blank" rel="noopener" title="Gitee地址">Gitee</a> 或者 <a href="https://coding.net/" target="_blank" rel="noopener" title="Coding地址">Coding</a>。</li><li>安装 <a href="https://git-scm.com/download/win" target="_blank" rel="noopener" title="Git下载地址">Git</a>，Git是开源的分布式版本控制系统，用于敏捷高效地处理项目。我们网站在本地搭建好了，需要使用Git同步到GitHub上。</li><li>本机要有 <a href="https://nodejs.org/zh-cn/download/" target="_blank" rel="noopener" title="node下载地址">node</a> 环境。这个我相信做前端开发的，搭建vue项目等等操作，都是需要 <code>node</code>的支持。</li><li><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener" title="Hexo中文文档地址">Hexo</a> 的文章使用 <code>Markdown</code> 文件，建议没有看过简单写法的可以先去学习以下。</li></ul><blockquote><p>以上为基础操作，就不具体介绍了，如果有疑问可以在<a href="https://windows99.github.io/whoami/" title="首页关于我的界面">关于</a>菜单找到我的联系方式，或者百度谷歌。</p></blockquote><h2 id="创建-Github-仓库"><a href="#创建-Github-仓库" class="headerlink" title="创建 Github 仓库"></a>创建 Github 仓库</h2><ol><li>点击左边的按钮或者右上方+号，弹出下拉框，选择第一个。</li></ol><p>   <img src="http://pic.wsktop.com/images/2019/12/31/1.png" alt="创建仓库1"></p><ol start="2"><li>在第一个输入框仓库名要写成 你GitHub的用户名+ <code>.github.io</code>，这里我已经拥有了这个仓库，所以会报出一个错误！箭头指向的按钮要点击勾选，初始化仓库。</li></ol><p>   <img src="http://pic.wsktop.com/images/2019/12/31/2.png" alt="创建仓库2"></p><ol start="3"><li>创建完后会进入你的仓库，在工具栏找到 <code>Settings</code>，下滑找到 <code>Github Pages</code>，如下图：</li></ol><p>   <img src="http://pic.wsktop.com/images/2019/12/31/3.png" alt="选择GitHub Pages"></p><p>在 <code>Source</code> 下的下拉框，选中第一个选项，等一会，在上方就会有一个地址，可以通过这个地址访问你的博客。到这里仓库就算是创建完成了！</p><h2 id="本地搭建-Hexo"><a href="#本地搭建-Hexo" class="headerlink" title="本地搭建 Hexo"></a>本地搭建 Hexo</h2><p> Hexo就是我们的个人博客网站的框架 ，首先可以找到空白文件夹，安装好 <a href="https://git-scm.com/download/win" target="_blank" rel="noopener" title="Git下载地址">Git</a> 可以右击，点击 git bash，打开git命令行（或者window下使用cmd命令行）输入：</p><pre><code class="bash">npm install hexo-cli -g //  或者yarn add hexo-cli -g</code></pre><p>这个安装可能时间会有些长，耐心等待。如果在国内可以使用<a href="https://npm.taobao.org/" target="_blank" rel="noopener" title="淘宝NPM镜像地址">淘宝NPM镜像</a>。</p><p>安装完后，初始化我们的博客，输入：</p><pre><code class="bash">hexo init blog</code></pre><p>初始化完成后，进入文件夹，并安装依赖</p><pre><code class="bash">cd blognpm install //  或者yarn</code></pre><p>最后我们启动 <code>hexo</code> 服务：</p><pre><code class="bash">hexo server</code></pre><p>浏览器进入 <a href="http://localhost:4000/" target="_blank" rel="noopener" title="本地hexo服务地址">http://localhost:4000/</a>，可以看到 <code>hexo</code> 给我们的初始界面。到这里，我们本地就算是搭建好了，更多 <code>hexo</code>的配置和方法，请参考 <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener" title="Hexo中文文档">官网</a></p><h2 id="推送网站"><a href="#推送网站" class="headerlink" title="推送网站"></a>推送网站</h2><p>首先我们需要配置好站点配置文件，在hexo根目录下有一个 <code>_config.yml</code> 的文件，在themes文件夹，里面也有个 <code>_config.yml</code> 文件，这个被称为<strong>主题配置文件</strong>，这里我们打开站点配置文件。</p><p>翻到最后修改为：</p><pre><code class="yaml">deploy:  type: git  repo: [你的github仓库地址]  branch: [分支]  message: [提交信息]</code></pre><p>其实就是给 <code>hexo deploy</code> 这个命令做相应的配置，需要在根目录安装Git部署插件：</p><pre><code class="bash">npm install hexo-deployer-git --save//  或者yarn add hexo-deployer-git --save</code></pre><p>这时，我们输入：</p><pre><code class="bash">hexo clean &amp; hexo generatehexo deploy</code></pre><p>输入我们的GitHub账户密码，就与服务器相关联了！</p><p>md文件格式我会抽时间补一篇文章。hexo的编写建立大家先去查看 <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener" title="Hexo中文文档地址">官网</a>，已经很详细了！本文只是做个记录。最后在2019年最后一天，祝大家2020年新年快乐！</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> GitHub </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
